global:
  default_inherits: default

tools:
  default:
    cores: 1
    mem: cores * 3 # note, some clusters will tolerate more than this
    env: {}
    params:
      nativeSpecification: "--nodes=1 --ntasks={cores} --ntasks-per-node={cores} --mem={mem*1024}"
    scheduling:
      preferred:
      tolerated:
        - general
      rejected:
        - pulsar
        - offline
    rules: []
    # rank: |
    #   import requests
    #   params = {
    #     'pretty': 'true',
    #     'db': 'pulsar-test',
    #     'q': 'SELECT last("percent_allocated") from "sinfo" group by "host"'
    #   }
    #   try:
    #     response = requests.get('http://stats.genome.edu.au:8086/query', params=params)
    #     data = response.json()
    #     cpu_by_destination = {s['tags']['host']:s['values'][0][1] for s in data.get('results')[0].get('series', [])}
    #     # sort by destination preference, and then by cpu usage
    #     candidate_destinations.sort(key=lambda d: (-1 * d.score(resource), cpu_by_destination.get(d.id)))
    #     final_destinations = candidate_destinations
    #   except Exception:
    #     log.exception("An error occurred while querying influxdb. Using a weighted random candidate destination")
    #     final_destinations = helpers.weighted_random_sampling(candidate_destinations)
    #   final_destinations
  upload1:
    cores: 2
  '.*iuc/fasta_stats/fasta-stats.*':
    cores: 2
    params:
      nativeSpecification: "--nodes=1 --ntasks={cores} --ntasks-per-node={cores} --mem=500"
    scheduling:
      tolerated:
        - pulsar
  '.*bwa_mem.*':
    cores: 2
    scheduling:
      tolerated:
        - pulsar
  '.*hifiasm.*':
    cores: 2
    scheduling:
      preferred:
        - pulsar
    rules:
      - match: input_size >= 0.2
        cores: 16

users:
  default:
    rules:
      - match: |
          from galaxy.jobs.rule_helper import RuleHelper
          from vortex.core.resources import TagType
          if resource.tags.filter(tag_value='highmem'):
            rule_helper = RuleHelper(app)
            # Find all destinations that support highmem
            destinations = [d.id for d in mapper.destinations.values()
                            if any(d.tags.filter(tag_value='highmem',
                                   tag_type=[TagType.REQUIRED, TagType.PREFERRED, TagType.TOLERATED]))]
            count = rule_helper.job_count(for_user_email=user.email, for_destinations=destinations)
            if count > 4:
              retval = True
            else:
              retval = False
          else:
            retval = False
          retval
        fail: "You cannot have more than 4 high-mem jobs running concurrently"
destinations:
  slurm:
    cores: 4
    mem: 15.5
    scheduling:
      tolerated:
        - pulsar
        - general
  pulsar_destination:
    cores: 4
    mem: 7.77
    scheduling:
      tolerated:
        - general
      required:
        - pulsar
  pulsar-nci-test:
    cores: 32
    mem: 96.38
    scheduling:
      tolerated:
        - general
      required:
        - pulsar
